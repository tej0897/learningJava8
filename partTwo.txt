Modern Java - Learn Java 8 features by coding it

                    ******

Contents:

    1. Functional Interfaces.
    2. Consumer and BiConsumer Interfaces.
    3. Predicate and BiPredicate Interfaces.
    4. Combining Predicate and Consumer Interfaces.
    5. Function and BiFuncation Interfaces.
    6. Unary and Binary Operators.
    7. Supplier Interface.

_______________________________________________________

Functional Interface:
    An Interface that has only one Abstract method.

    New Functional Interfaces introduced in Java 8:

    1. Consumer - BiConsumer
    2. Predicate - BiPredicate
    3. Function - BiFunction, UnaryOperator, BinaryOperator
    4. Supplier

_______________________________________________________

Consumer Interface:

    Accept an input and perform some operation on that input.

    Example: Accepts an input, performs uppercase operation on it and displays the result.

    IRL Use-case: From List of Students, filter students based on their grade and display them.
    (conditional filtering and displaying them)

    1. Has @FunctionalInterface annotation.
    2. It has one method: accept(T t);
    3. It just accepts an input. Does not provide any output.
    4. It has another method: default
    5. Use "accept()" to pass in the input.

_______________________________________________________

BiConsumer Interface:

    It accepts two inputs, performs some operation on them.

    1. There are two methods in BiConsumer Interface: Accept() and default()

    UseCase:
        a. Takes two input, print values of these two inputs or Multiply and divide the inputs and print the values. (andThen method)
        b. Print Name and Activities of the Student, since it takes two inputs.

_______________________________________________________

Predicate Functional Interface:

    1. It has Boolean method and it accepts input.
    2. It takes input, performs operation and returns a Boolean value.
    3. It has other default methods like "and(), negate(), or(), isEquals()".
    4. Benefit is Code Reuse-ability.
    5. PREDICATE CHAINING:
    Use PredicateAnd to check two conditions like, if the number is divisible by 2 and 5. or() to check if the condition passes any one, negate() to negate the result.

    UseCases:
        1. Check the input number is even or not.
        2. Check if the input is divisible by 2 and 5.
        3. Check the grade level. (greater than 3)
        4. Multiple filtering checks like grade, GPA etc.

_______________________________________________________

Combining Predicate and Consumer:
(IMPORTANT) teaches how to handle instance methods. Check Code.

    UseCase: Listing the Name and Activities based on filtering conditions using Predicate and Consumer.

    We are creating instance methods here instead of static methods. Why?
        Just to show that lambdas work the same irrespective of Instance method or static method.

_______________________________________________________

BiPredicate Functional Interface:

    1. Accepts two inputs and returns boolean output.
    2. Had default methods same as predicate. and, or, negate.

_______________________________________________________

